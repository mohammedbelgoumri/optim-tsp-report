\chapter{Approximate Solutions 1 (Heuristics)}

Despite them being exact, the algorithms we introduced so far are not always practical to use on a real world problem. This is due to their computational expense. No efficient exact algorithm known for the \TSP. In fact, under the assumption \(\classP\neq\classNP\), no such algorithm exists. A reasonable alternative to consider is finding an efficient \emph{approximate} algorithm.

\section{Nearest Neighbor}

    Approximate methods sacrifice the exactness of the solution for efficiency. The extent to which we can tolerate loss of accuracy is however limited. A constant time solution is useless if it gives a sufficiently large error. 
    
    All approximate methods are based on a compromise between accuracy and time. Nearest Neighbor being one such method, it is built on one such compromise. It places a higher emphasis on runtime than accuracy. In deed, we will see that Nearest Neighbor is the fastest among the algorithms we will consider. Correspondingly, it also gives the most mediocre solutions.

    \subsection{The Algorithm}

    Nearest Neighbor is a \emph{greedy} algorithm. Greedy algorithms are iterative algorithms that take the optimal action at each iteration. The choice of action is based only on the information available at the current state. No backtracking is performed. They are therefore seldom able to find optimal solutions.

    Nearest Neighbor in particular explores one branch of the search tree traversed by Branch and Bound. It is in deed equivalent to the first iteration of Branch and Bound. 
    % \AtBeginEnvironment{algorithm}{\let\textnormal\ttfamily}
    % \BeforeBeginEnvironment{algorithm}{\let\textnormal\ttfamily}
    % \let\textnormal\ttfamily
        \begin{algorithm}
            \SetKwFunction{nearestNeighbours}{nearestNeighbours}
        \caption{Nearest Neighbor}
        \label{algo:nearest-neighbor}
            \DontPrintSemicolon
            \KwIn{instance} \comment{represented as an adjacency matrix}
            \Begin{
                path \(\gets\) [0] \;
                {unvisited} \(\gets\) {cities} \(-\) {[origin]}\;
                \While{unvisited \(\neq \emptyset\)}{
                    last \(\gets\) path[-1]
                    \ForAll{city in \nearestNeighbours{last}}{
                        \If{city \(\notin\) unvisited}{
                            break
                        }
                        path \(\gets\) path + [city]\;
                        visited \(\gets\) visited - [city]
                    }
                }
                \KwOut{{path}}
            }
    \end{algorithm}

    \subsection{Complexity Analysis}
    
    

    \section{2-OPT and 3-OPT}
